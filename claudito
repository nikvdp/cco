#!/bin/bash

set -e

# Determine if we're running from installation or development
if [[ -d "$HOME/.local/share/claudito/.git" && "$(basename "$(dirname "$0")")" != "claudito" ]]; then
    # Running from symlink, use installation directory
    CLAUDITO_INSTALLATION_DIR="$HOME/.local/share/claudito"
else
    # Running from development directory
    CLAUDITO_INSTALLATION_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

IMAGE_NAME="claudito:latest"
CONTAINER_NAME="claudito-$(basename "$PWD")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[claudito]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[claudito]${NC} $1"
}

error() {
    echo -e "${RED}[claudito]${NC} $1" >&2
}

# Check if Docker is available
check_docker() {
    if ! command -v docker &> /dev/null; then
        error "Docker is not installed or not in PATH"
        exit 1
    fi
    
    if ! docker info &> /dev/null; then
        error "Docker daemon is not running"
        exit 1
    fi
}

# Determine Claude Code config directory following priority order:
# 1. CLAUDE_CONFIG_DIR env var (if set)
# 2. XDG_CONFIG_HOME/claude or ~/.config/claude (new default since v1.0.30)
# 3. ~/.claude (legacy fallback)
get_claude_config_dir() {
    if [ -n "$CLAUDE_CONFIG_DIR" ]; then
        echo "$CLAUDE_CONFIG_DIR"
    elif [ -n "$XDG_CONFIG_HOME" ]; then
        echo "$XDG_CONFIG_HOME/claude"
    elif [ -d "$HOME/.config" ]; then
        echo "$HOME/.config/claude"
    else
        echo "$HOME/.claude"
    fi
}

# Find where Claude Code actually stores its configuration
find_claude_config_dir() {
    local primary_dir=$(get_claude_config_dir)
    local legacy_dir="$HOME/.claude"
    
    # Check primary location first
    if [ -d "$primary_dir" ] && [ -f "$primary_dir/.credentials.json" -o -n "$(command -v security)" ]; then
        echo "$primary_dir"
        return
    fi
    
    # Fall back to legacy location
    if [ -d "$legacy_dir" ] && [ -f "$legacy_dir/.credentials.json" -o -n "$(command -v security)" ]; then
        echo "$legacy_dir"
        return
    fi
    
    # Return primary location for error reporting
    echo "$primary_dir"
}

# Extract system Claude Code configuration for Docker build
# CRITICAL: This copies SYSTEM config to .claude-system/ (not .claude/)
# to avoid corrupting project-specific .claude/ directories
setup_system_credentials() {
    log "Setting up system Claude Code configuration..."
    
    local claude_config_dir=$(find_claude_config_dir)
    
    # Clean up any existing system config staging area in installation directory
    rm -rf "$CLAUDITO_INSTALLATION_DIR/.claude-system"
    mkdir -p "$CLAUDITO_INSTALLATION_DIR/.claude-system"
    
    # Copy system Claude configuration directory if it exists
    if [ -d "$claude_config_dir" ]; then
        log "Copying system Claude Code configuration from $claude_config_dir"
        cp -r "$claude_config_dir"/* "$CLAUDITO_INSTALLATION_DIR/.claude-system/" 2>/dev/null || true
    else
        error "No Claude Code configuration found at $claude_config_dir"
        error "Please run 'claude' first to authenticate, then try again."
        exit 1
    fi
    
    # IMPORTANT: Do NOT copy credentials to avoid baking them into Docker image
    # Credentials will be mounted at runtime from Keychain or host files
    
    # Verify credentials exist but don't copy them
    if command -v security &> /dev/null; then
        if ! security find-generic-password -s "Claude Code-credentials" -a "$USER" -w >/dev/null 2>&1; then
            error "No Claude Code credentials found in macOS Keychain"
            error "Please run 'claude' first to authenticate, then try again."
            exit 1
        fi
        log "Verified Claude Code credentials in macOS Keychain"
    elif [ -f "$claude_config_dir/.credentials.json" ]; then
        log "Verified existing Claude Code credentials file"
    else
        error "No Claude Code credentials found!"
        error "Please run 'claude' first to authenticate, then try again."
        exit 1
    fi
    
    # Copy .claude.json from home directory (if exists) with OAuth account info
    if [ -f "$HOME/.claude.json" ]; then
        log "Copying .claude.json with OAuth account info"
        # Extract minimal OAuth info for fresh start, or copy full file
        if command -v jq &> /dev/null; then
            jq '{oauthAccount: .oauthAccount, hasCompletedOnboarding: true, lastOnboardingVersion: "1.0.31"}' "$HOME/.claude.json" > "$CLAUDITO_INSTALLATION_DIR/.claude-system/.claude.json" 2>/dev/null || cp "$HOME/.claude.json" "$CLAUDITO_INSTALLATION_DIR/.claude-system/.claude.json"
        else
            cp "$HOME/.claude.json" "$CLAUDITO_INSTALLATION_DIR/.claude-system/.claude.json"
        fi
    fi
    
    log "System Claude Code configuration prepared for container build"
}

# Build Docker image
build_image() {
    local host_uid=$(id -u)
    local host_gid=$(id -g)
    local original_dir="$PWD"
    
    log "Building claudito Docker image..."
    
    # Always build from installation directory
    cd "$CLAUDITO_INSTALLATION_DIR" || {
        error "Claudito installation not found at $CLAUDITO_INSTALLATION_DIR"
        error "Run: curl -fsSL https://raw.githubusercontent.com/nikvdp/claudito/master/install.sh | bash"
        exit 1
    }
    
    local build_args=(
        --build-arg HOST_UID="$host_uid"
        --build-arg HOST_GID="$host_gid"
    )
    
    # Add custom packages if specified
    if [[ ${#custom_packages[@]} -gt 0 ]]; then
        local packages_list=$(IFS=' '; echo "${custom_packages[*]}")
        log "Installing additional packages: $packages_list"
        build_args+=(--build-arg CUSTOM_PACKAGES="$packages_list")
    fi
    
    docker build -t "$IMAGE_NAME" "${build_args[@]}" .
    cd "$original_dir"
    log "Image built successfully"
}

# Update claudito installation
update_claudito() {
    if [[ ! -d "$CLAUDITO_INSTALLATION_DIR/.git" ]]; then
        error "Claudito installation not found at $CLAUDITO_INSTALLATION_DIR"
        error "Run: curl -fsSL https://raw.githubusercontent.com/nikvdp/claudito/master/install.sh | bash"
        exit 1
    fi
    
    local original_dir="$PWD"
    cd "$CLAUDITO_INSTALLATION_DIR"
    
    log "Updating claudito installation..."
    
    # Check for local modifications
    if ! git diff --quiet HEAD 2>/dev/null; then
        warn "WARNING: Your claudito installation has local modifications."
        warn "Most users should reset to the latest version (this is safe)."
        warn "Only say 'no' if you've customized claudito yourself."
        echo
        read -p "Reset to latest version and lose local changes? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            warn "Skipping update to preserve local changes"
            cd "$original_dir"
            return 1
        fi
        log "Resetting to latest version..."
        git reset --hard origin/master
    fi
    
    git fetch origin
    git pull origin master
    local new_version=$(git rev-parse --short HEAD)
    log "Updated to $new_version"
    
    log "Rebuilding Docker image with latest changes..."
    build_image
    
    cd "$original_dir"
    log "Update complete!"
}

# Show version information
show_version() {
    if [[ -d "$CLAUDITO_INSTALLATION_DIR/.git" ]]; then
        local version=$(cd "$CLAUDITO_INSTALLATION_DIR" && git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        local install_type="installation"
    else
        local version="dev"
        local install_type="development"
    fi
    
    echo "claudito $version ($install_type)"
    echo "Installation: $CLAUDITO_INSTALLATION_DIR"
}

# Main run function
run_container() {
    local host_uid=$(id -u)
    local host_gid=$(id -g)
    local current_dir="$PWD"
    
    log "Starting claudito container..."
    log "Using host UID:GID ${host_uid}:${host_gid}"
    
    # Remove existing container if it exists
    docker rm -f "$CONTAINER_NAME" &> /dev/null || true
    
    # Detect if we have a TTY
    local tty_flag=""
    if [ -t 0 ] && [ -t 1 ]; then
        tty_flag="-it"
    fi
    
    local docker_args=(
        --rm $tty_flag
        --name "$CONTAINER_NAME"
        --cap-add=NET_ADMIN
        --cap-add=NET_RAW
        --user "${host_uid}:${host_gid}"
        -v "$current_dir":"$current_dir"
        -w "$current_dir"
    )
    
    # Pass through relevant environment variables
    local env_vars=(
        "ANTHROPIC_API_KEY"
        "ANTHROPIC_BASE_URL" 
        "CLAUDE_CONFIG_DIR"
        "XDG_CONFIG_HOME"
        "NO_COLOR"
        "TERM"
        "COLORTERM"
        "LANG"
        "LC_ALL"
        "TZ"
        "HTTP_PROXY"
        "HTTPS_PROXY"
        "NO_PROXY"
        "GIT_AUTHOR_NAME"
        "GIT_AUTHOR_EMAIL"
        "GIT_COMMITTER_NAME"
        "GIT_COMMITTER_EMAIL"
    )
    
    for var in "${env_vars[@]}"; do
        if [ -n "${!var}" ]; then
            docker_args+=(-e "$var=${!var}")
        fi
    done
    
    # Add custom environment variables from command line
    for custom_env in "${custom_env_vars[@]}"; do
        if [[ "$custom_env" == *"="* ]]; then
            # KEY=VALUE format
            docker_args+=(-e "$custom_env")
        else
            # KEY format - pass through from host environment
            if [ -n "${!custom_env}" ]; then
                docker_args+=(-e "$custom_env=${!custom_env}")
            fi
        fi
    done
    
    # Load .env file if it exists
    [ -f ".env" ] && docker_args+=(--env-file .env)
    
    # Enable Docker access if requested
    if [ "$docker_access" = true ]; then
        # Check for Docker socket locations (Linux and macOS with Docker Desktop)
        if [ -S "/var/run/docker.sock" ]; then
            log "Enabling Docker access via /var/run/docker.sock"
            docker_args+=(-v "/var/run/docker.sock":"/var/run/docker.sock")
        elif [ -S "$HOME/.docker/run/docker.sock" ]; then
            log "Enabling Docker access via $HOME/.docker/run/docker.sock"
            docker_args+=(-v "$HOME/.docker/run/docker.sock":"/var/run/docker.sock")
        else
            warn "Docker socket not found - Docker access may not work"
            warn "Tried: /var/run/docker.sock, $HOME/.docker/run/docker.sock"
        fi
    fi
    
    # Set up Claude Code configuration hierarchy in container
    local host_system_claude_dir=$(find_claude_config_dir)
    local container_system_claude_dir="/home/user/.claude"
    local project_claude_dir="$current_dir/.claude"
    
    # Set CLAUDE_CONFIG_DIR for the container to use the home directory
    docker_args+=(-e "CLAUDE_CONFIG_DIR=$container_system_claude_dir")
    
    # Extract fresh credentials from Keychain and mount individual files
    # IMPORTANT: Mount individual files to avoid directory mount precedence issues
    if command -v security &> /dev/null; then
        log "Mounting fresh credentials from macOS Keychain..."
        TEMP_CREDS_DIR="/tmp/claudito-creds-$$"
        mkdir -p "$TEMP_CREDS_DIR"
        
        if KEYCHAIN_CREDENTIALS=$(security find-generic-password -s "Claude Code-credentials" -a "$USER" -w 2>/dev/null); then
            echo "$KEYCHAIN_CREDENTIALS" > "$TEMP_CREDS_DIR/.credentials.json"
            docker_args+=(-v "$TEMP_CREDS_DIR/.credentials.json":"$container_system_claude_dir/.credentials.json:ro")
            log "Fresh credentials mounted from macOS Keychain"
            
            # Clean up temp directory on exit
            trap "rm -rf $TEMP_CREDS_DIR" EXIT
        fi
    fi
    
    # Mount individual system config files (avoid directory mount conflicts)
    if [ -f "$host_system_claude_dir/settings.json" ]; then
        docker_args+=(-v "$host_system_claude_dir/settings.json":"$container_system_claude_dir/settings.json:ro")
        log "Mounting system settings.json (read-only)"
    fi
    
    # Mount project-specific .claude directory (read-write for project settings)
    if [ -d "$project_claude_dir" ]; then
        log "Mounting project Claude config from $project_claude_dir (read-write)"
        docker_args+=(-v "$project_claude_dir":"$project_claude_dir")
    fi
    
    # Mount .claude.json from home level (contains project paths and UI state)
    if [ -f "$HOME/.claude.json" ]; then
        docker_args+=(-v "$HOME/.claude.json":"/home/user/.claude.json:ro")
        log "Mounting .claude.json from home directory (read-only)"
    fi
    
    # Bind mount common config files
    [ -f "$HOME/.gitconfig" ] && docker_args+=(-v "$HOME/.gitconfig":"/home/user/.gitconfig:ro")
    [ -d "$HOME/.ssh" ] && docker_args+=(-v "$HOME/.ssh":"/home/user/.ssh:ro")
    
    # Run the container
    if [ "$shell_mode" = true ]; then
        docker run "${docker_args[@]}" "$IMAGE_NAME" bash
    else
        if [ ${#claude_args[@]} -eq 0 ]; then
            docker run "${docker_args[@]}" "$IMAGE_NAME"
        else
            docker run "${docker_args[@]}" "$IMAGE_NAME" claude --dangerously-skip-permissions "${claude_args[@]}"
        fi
    fi
}

# Handle command line arguments
rebuild_image=false
claude_args=()
shell_mode=false
custom_env_vars=()
custom_packages=()
docker_access=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --rebuild)
            rebuild_image=true
            shift
            ;;
        --self-update)
            update_claudito
            exit 0
            ;;
        --version|-v)
            show_version
            exit 0
            ;;
        --shell)
            shell_mode=true
            shift
            ;;
        --env|-e)
            if [[ $# -lt 2 ]]; then
                error "--env requires an argument (KEY=VALUE or KEY)"
                exit 1
            fi
            custom_env_vars+=("$2")
            shift 2
            ;;
        --packages|-p)
            if [[ $# -lt 2 ]]; then
                error "--packages requires an argument (package1,package2,...)"
                exit 1
            fi
            IFS=',' read -ra ADDR <<< "$2"
            for pkg in "${ADDR[@]}"; do
                custom_packages+=("$pkg")
            done
            shift 2
            ;;
        --docker)
            docker_access=true
            shift
            ;;
        --help|-h)
            echo "claudito - Secure Claude Code Container"
            echo ""
            echo "Usage: $0 [OPTIONS] [CLAUDE_ARGS...]"
            echo ""
            echo "Options:"
            echo "  --rebuild         Force rebuild of Docker image"
            echo "  --self-update     Update claudito to latest version"
            echo "  --version, -v     Show version information"
            echo "  --shell           Start interactive shell for debugging"
            echo "  --env, -e KEY=VAL Set environment variable in container"
            echo "  --packages, -p    Install additional apt packages into container"
            echo "  --docker          Enable Docker access (bind mount Docker socket)"
            echo "  --help, -h        Show this help message"
            echo ""
            echo "All other arguments are passed to Claude Code inside the container."
            echo ""
            echo "Environment Variables:"
            echo "  - Automatically loads .env file if present"
            echo "  - Passes through ANTHROPIC_API_KEY, proxy settings, git config, etc."
            echo "  - Use --env to set custom variables"
            echo ""
            echo "Requirements:"
            echo "  - Docker installed and running"
            echo "  - Claude Code authenticated (run 'claude' first)"
            exit 0
            ;;
        *)
            # Pass all other arguments to Claude
            claude_args+=("$1")
            shift
            ;;
    esac
done

# Main execution flow
main() {
    log "Starting claudito..."
    
    check_docker
    setup_system_credentials
    
    # Rebuild image if requested, custom packages specified, or if image doesn't exist
    if [ "$rebuild_image" = true ] || [ ${#custom_packages[@]} -gt 0 ]; then
        if [ ${#custom_packages[@]} -gt 0 ]; then
            log "Custom packages specified, rebuilding image..."
        else
            log "Rebuilding claudito image..."
        fi
        docker image rm "$IMAGE_NAME" &> /dev/null || true
        build_image
    elif ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
        log "No existing image found, building..."
        build_image
    else
        log "Using existing claudito image"
    fi
    
    run_container
}

main