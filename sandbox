#!/usr/bin/env bash
# sandbox - RW only in the current directory; RO everywhere else.
# Works on Linux (bubblewrap) and macOS (Seatbelt via sandbox-exec).
# Add extra write holes with -w/--write PATH (repeatable). PATH may be a dir or file.
# Env vars are inherited; networking is untouched.

set -euo pipefail

usage() {
	echo "Usage: sandbox [--safe] [--allow-keychain] [-w|--write PATH] [--read-only PATH] [--deny PATH]... [-- [BACKEND_ARGS...] --] <command> [args...]"
	echo "  PATH may be a directory (RW under it) or a file (RW to that file only)."
	echo "  --allow-keychain: Allow access to macOS Keychain (DANGEROUS - grants read/write access to ALL Keychain entries)"
	echo "  BACKEND_ARGS: Extra arguments passed directly to bwrap (Linux) or sandbox-exec (macOS)"
	echo "                Must be enclosed between -- markers if provided"
	exit 1
}

# Expand ~ and return absolute, symlink-free path (for dirs or files).
# For non-existent files, ensure parent exists and return absolute would-be path.
abs_path() {
	local p="$1"
	# manual tilde expansion (covers the case where user quoted it)
	if [[ "$p" == "~" || "$p" == ~/* ]]; then
		p="${p/#\~/$HOME}"
	fi
	if [[ -e "$p" ]]; then
		if [[ -d "$p" ]]; then
			(cd "$p" && pwd -P)
		else
			(cd "$(dirname -- "$p")" && printf '%s/%s\n' "$(pwd -P)" "$(basename -- "$p")")
		fi
	else
		local parent base
		parent="$(dirname -- "$p")"
		base="$(basename -- "$p")"
		[[ -d "$parent" ]] || {
			echo "sandbox: parent directory does not exist: $parent" >&2
			exit 2
		}
		(cd "$parent" && printf '%s/%s\n' "$(pwd -P)" "$base")
	fi
}

# Escape a path for Seatbelt policy quoting: escape \ and "
policy_quote() {
	local s="$1"
	s="${s//\\/\\\\}"
	s="${s//\"/\\\"}"
	printf '%s' "$s"
}

# Parse CLI
write_paths=()
ro_paths=()
deny_paths=()
backend_extra_args=()
safe_mode=false
allow_keychain=false
while [[ $# -gt 0 ]]; do
	case "$1" in
	--safe)
		safe_mode=true
		shift
		;;
	-w | --write)
		shift
		[[ $# -gt 0 ]] || usage
		write_paths+=("$(abs_path "$1")")
		shift
		;;
	--read-only)
		shift
		[[ $# -gt 0 ]] || usage
		ro_paths+=("$(abs_path "$1")")
		shift
		;;
	--deny)
		shift
		[[ $# -gt 0 ]] || usage
		deny_paths+=("$(abs_path "$1")")
		shift
		;;
	--allow-keychain)
		allow_keychain=true
		shift
		;;
	-h | --help) usage ;;
	--)
		shift
		# If another -- exists later, treat args between as backend args.
		# Otherwise, this is the standard end-of-options marker for the command.
		has_backend_args=false
		for arg in "$@"; do
			if [[ "$arg" == "--" ]]; then
				has_backend_args=true
				break
			fi
		done
		if [[ "$has_backend_args" == true ]]; then
			while [[ $# -gt 0 && "$1" != "--" ]]; do
				backend_extra_args+=("$1")
				shift
			done
			if [[ "${1:-}" == "--" ]]; then
				shift
			fi
		fi
		break
		;;
	-*)
		echo "sandbox: unknown option: $1" >&2
		usage
		;;
	*) break ;;
	esac
done
[[ $# -gt 0 ]] || usage

OS="$(uname -s)"
PWD_ABS="$(pwd -P)"

run_linux() {
	command -v bwrap >/dev/null 2>&1 || {
		echo "sandbox: bubblewrap (bwrap) is not installed." >&2
		exit 127
	}

	# Get the directory where this script is located (for finding seccomp filters)
	local script_dir
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	local seccomp_dir="$script_dir/seccomp"
	local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/cco"

	# Setup seccomp filter to block TIOCSTI/TIOCLINUX sandbox escape (CVE-2017-5226, CVE-2023-1523)
	local seccomp_filter=""
	local arch
	arch="$(uname -m)"

	case "$arch" in
	x86_64)
		if [[ -f "$seccomp_dir/tiocsti_filter_x86_64.bpf" ]]; then
			seccomp_filter="$seccomp_dir/tiocsti_filter_x86_64.bpf"
		fi
		;;
	aarch64)
		if [[ -f "$seccomp_dir/tiocsti_filter_aarch64.bpf" ]]; then
			seccomp_filter="$seccomp_dir/tiocsti_filter_aarch64.bpf"
		fi
		;;
	*)
		# Exotic architecture - try to compile from source
		local compiled_filter="$cache_dir/tiocsti_filter_${arch}.bpf"
		local source_file="$seccomp_dir/tiocsti_filter.c"
		local needs_rebuild=false

		# Check if we need to rebuild: no cache, or source is newer than cache
		if [[ ! -f "$compiled_filter" ]]; then
			needs_rebuild=true
		elif [[ -f "$source_file" && "$source_file" -nt "$compiled_filter" ]]; then
			needs_rebuild=true
		fi

		if [[ "$needs_rebuild" == true && -f "$source_file" ]]; then
			# Try to compile the filter
			if command -v cc >/dev/null 2>&1; then
				mkdir -p "$cache_dir"
				local filter_gen="$cache_dir/tiocsti_filter_gen"
				if cc -O2 -o "$filter_gen" "$source_file" 2>/dev/null; then
					if "$filter_gen" "$compiled_filter" >/dev/null 2>&1; then
						rm -f "$filter_gen"
					fi
				fi
			fi
		fi

		if [[ -f "$compiled_filter" ]]; then
			seccomp_filter="$compiled_filter"
		fi
		;;
	esac

	# Warn if we couldn't set up seccomp protection
	if [[ -z "$seccomp_filter" ]]; then
		echo "sandbox: WARNING: Could not set up TIOCSTI protection for architecture '$arch'." >&2
		echo "sandbox: The sandbox may be vulnerable to terminal injection attacks." >&2
		echo "sandbox: To fix on exotic architectures, install a C compiler (gcc/clang)." >&2
	fi

	# 1) Base: make root view RO; keep /dev, /proc, and a tmpfs /tmp; DO NOT unshare net.
	args=(--die-with-parent
		--ro-bind / /
		--dev /dev
		--proc /proc
		--tmpfs /tmp
	)

	# Add seccomp filter if available (blocks TIOCSTI/TIOCLINUX sandbox escape)
	# Use fd 200 to avoid collision with common inherited fds
	if [[ -n "$seccomp_filter" && -f "$seccomp_filter" ]]; then
		args+=(--seccomp 200)
	fi

	# 2) Common top-level mount points RO so writable mounts canâ€™t leak through.
	for p in /home /var /root /run /opt /srv /media /mnt /usr /etc /sys; do
		[[ -e "$p" ]] && args+=(--ro-bind "$p" "$p")
	done

	# 3) If safe mode enabled, hide the rest of $HOME by default.
	if [[ "$safe_mode" == true ]]; then
		args+=(--tmpfs "$HOME")
	fi

	# 4) Overlay rules (rw, ro, deny) so they take precedence.
	# Always include the current directory at its real path.
	args+=(--bind "$PWD_ABS" "$PWD_ABS")

	# Helper temp resources for deny overlays
	cleanup_paths=()
	cleanup_overlays() {
		for p in "${cleanup_paths[@]+"${cleanup_paths[@]}"}"; do
			if [[ -n "$p" && -e "$p" ]]; then
				rm -rf "$p"
			fi
		done
	}

	# Helper: create a deny directory with explicit permissions
	make_deny_dir() {
		local mode="$1"
		local dir
		dir=$(mktemp -d)
		chmod "$mode" "$dir"
		cleanup_paths+=("$dir")
		printf '%s' "$dir"
	}

	# Helper: create a deny file with explicit permissions
	make_deny_file() {
		local mode="$1"
		local file
		file=$(mktemp)
		: >"$file"
		chmod "$mode" "$file"
		cleanup_paths+=("$file")
		printf '%s' "$file"
	}

	# Helper: ensure path under overlay exists (permissions are set later).
	# Files and dirs created are recorded so we can chmod them after the overlay is built.
	deny_overlay_files=()
	deny_overlay_dirs=()
	create_deny_overlay_target() {
		local overlay_root="$1"
		local deny_root="$2"
		local target="$3"
		local rel
		rel="${target#"$deny_root"/}"
		[[ "$target" == "$deny_root" ]] && return 0

		local is_dir=false
		if [[ -d "$target" ]]; then
			is_dir=true
		fi

		if [[ "$is_dir" == true ]]; then
			local parent="$overlay_root"
			IFS='/' read -r -a parts <<<"$rel"
			for part in "${parts[@]}"; do
				parent="$parent/$part"
				if [[ ! -d "$parent" ]]; then
					mkdir -p "$parent"
				fi
				deny_overlay_dirs+=("$parent")
			done
		else
			local parent="$overlay_root"
			IFS='/' read -r -a parts <<<"$rel"
			for part in "${parts[@]:0:${#parts[@]}-1}"; do
				parent="$parent/$part"
				if [[ ! -d "$parent" ]]; then
					mkdir -p "$parent"
				fi
				deny_overlay_dirs+=("$parent")
			done
			: >"$overlay_root/$rel"
			deny_overlay_files+=("$overlay_root/$rel")
		fi
	}

	# Helper: check if path is under (or equal to) another path
	is_subpath_of() {
		local child="$1"
		local parent="$2"
		[[ "$child" == "$parent" || "$child" == "$parent"/* ]]
	}

	# Compute which allow paths are under which deny paths
	# Format: associative tracking via arrays
	declare -a deny_has_exceptions=()
	for i in "${!deny_paths[@]}"; do
		deny_has_exceptions[i]=false
		local deny="${deny_paths[$i]}"
		for wp in "${write_paths[@]+"${write_paths[@]}"}"; do
			if is_subpath_of "$wp" "$deny"; then
				deny_has_exceptions[i]=true
				break
			fi
		done
		if [[ "${deny_has_exceptions[$i]}" == false ]]; then
			for rp in "${ro_paths[@]+"${ro_paths[@]}"}"; do
				if is_subpath_of "$rp" "$deny"; then
					deny_has_exceptions[i]=true
					break
				fi
			done
		fi
	done

	if [[ "${CCO_DEBUG:-}" == "1" ]]; then
		for i in "${!deny_paths[@]}"; do
			if [[ "${deny_has_exceptions[$i]}" == true ]]; then
				echo "DEBUG: Deny path with exceptions: ${deny_paths[$i]}" >&2
			fi
		done
	fi

	# Process write paths that are NOT under any deny path
	for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
		local under_deny=false
		for deny in "${deny_paths[@]+"${deny_paths[@]}"}"; do
			if is_subpath_of "$ap" "$deny"; then
				under_deny=true
				break
			fi
		done
		if [[ "$under_deny" == false ]]; then
			# Ensure targets exist so bind succeeds
			if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
			args+=(--bind "$ap" "$ap")
		fi
	done

	# Process read-only paths that are NOT under any deny path
	for ap in "${ro_paths[@]+"${ro_paths[@]}"}"; do
		local under_deny=false
		for deny in "${deny_paths[@]+"${deny_paths[@]}"}"; do
			if is_subpath_of "$ap" "$deny"; then
				under_deny=true
				break
			fi
		done
		if [[ "$under_deny" == false ]]; then
			if [[ -d "$ap" ]]; then
				args+=(--ro-bind "$ap" "$ap")
			else
				if [[ ! -e "$ap" ]]; then : >"$ap"; fi
				args+=(--ro-bind "$ap" "$ap")
			fi
		fi
	done

	# Process deny paths
	for i in "${!deny_paths[@]}"; do
		local ap="${deny_paths[$i]}"

		if [[ "${deny_has_exceptions[$i]}" == true ]]; then
			# Deny path with exceptions: use exec-only overlay, then mount exceptions on top
			if [[ -d "$ap" ]]; then
				deny_dir=$(make_deny_dir 755)
				deny_overlay_files=()
				deny_overlay_dirs=()
				# Pre-create mount points inside the overlay so bwrap can bind exceptions
				for wp in "${write_paths[@]+"${write_paths[@]}"}"; do
					if is_subpath_of "$wp" "$ap"; then
						create_deny_overlay_target "$deny_dir" "$ap" "$wp"
					fi
				done
				for rp in "${ro_paths[@]+"${ro_paths[@]}"}"; do
					if is_subpath_of "$rp" "$ap"; then
						create_deny_overlay_target "$deny_dir" "$ap" "$rp"
					fi
				done
				# Lock down permissions after creating targets
				for d in "${deny_overlay_dirs[@]+"${deny_overlay_dirs[@]}"}"; do
					chmod 111 "$d"
				done
				chmod 111 "$deny_dir"
				if [[ ${#deny_overlay_files[@]} -gt 0 ]]; then
					chmod 000 "${deny_overlay_files[@]}"
				fi
				args+=(--ro-bind "$deny_dir" "$ap")
			else
				# For files, use no-permission overlay
				deny_file=$(make_deny_file 000)
				args+=(--ro-bind "$deny_file" "$ap")
			fi

			# Now mount allowed subpaths on top of the tmpfs
			for wp in "${write_paths[@]+"${write_paths[@]}"}"; do
				if is_subpath_of "$wp" "$ap"; then
					if [[ -d "$wp" ]]; then
						args+=(--bind "$wp" "$wp")
					else
						if [[ ! -e "$wp" ]]; then : >"$wp"; fi
						args+=(--bind "$wp" "$wp")
					fi
				fi
			done
			for rp in "${ro_paths[@]+"${ro_paths[@]}"}"; do
				if is_subpath_of "$rp" "$ap"; then
					if [[ -d "$rp" ]]; then
						args+=(--ro-bind "$rp" "$rp")
					else
						if [[ ! -e "$rp" ]]; then : >"$rp"; fi
						args+=(--ro-bind "$rp" "$rp")
					fi
				fi
			done
		else
			# Deny path without exceptions: use no-permission overlay
			if [[ -d "$ap" ]]; then
				deny_dir=$(make_deny_dir 000)
				args+=(--ro-bind "$deny_dir" "$ap")
			elif [[ -f "$ap" ]]; then
				deny_file=$(make_deny_file 000)
				args+=(--ro-bind "$deny_file" "$ap")
			else
				deny_dir=$(make_deny_dir 000)
				args+=(--ro-bind "$deny_dir" "$ap")
			fi
		fi
	done
	args+=(--chdir "$PWD_ABS")

	# Add any extra backend args
	if [[ ${#backend_extra_args[@]} -gt 0 ]]; then
		args+=("${backend_extra_args[@]}")
	fi

	# Execute bwrap with seccomp filter on fd 200 if available
	if [[ -n "$seccomp_filter" && -f "$seccomp_filter" ]]; then
		bwrap "${args[@]}" "$@" 200<"$seccomp_filter"
	else
		bwrap "${args[@]}" "$@"
	fi
	local status=$?
	cleanup_overlays
	exit $status
}

run_macos() {
	command -v sandbox-exec >/dev/null 2>&1 || {
		echo "sandbox: sandbox-exec not found on this macOS." >&2
		exit 127
	}

	# Ensure any whitelisted *files* exist so Seatbelt can actually write to them
	for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
		if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
	done
	for ap in "${ro_paths[@]+"${ro_paths[@]}"}"; do
		if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
	done

	# Build a Seatbelt profile that denies writes globally, then whitelists:
	# - The current directory (subpath)
	# - Any -w directories (subpath)
	# - Any -w files (literal)
	policy_file="$(mktemp -t sandbox.seatbelt.XXXXXX)"

	keep_policy=false
	if [[ "${CCO_DEBUG:-}" == "1" ]]; then
		echo "DEBUG: Seatbelt policy file: $policy_file" >&2
		echo "DEBUG: Write paths being added:" >&2
		printf "  PWD: %s\n" "$PWD_ABS" >&2
		for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
			printf "  Additional: %s\n" "$ap" >&2
		done
		keep_policy=true
	fi

	# Helper: check if path is under (or equal to) another path
	is_subpath_of() {
		local child="$1"
		local parent="$2"
		[[ "$child" == "$parent" || "$child" == "$parent"/* ]]
	}

	# Compute allow exceptions that fall under deny paths
	# These need special ordering: deny first, then allow exception
	declare -a deny_exceptions_write=()
	declare -a deny_exceptions_ro=()

	for deny in "${deny_paths[@]+"${deny_paths[@]}"}"; do
		for wp in "${write_paths[@]+"${write_paths[@]}"}"; do
			if is_subpath_of "$wp" "$deny"; then
				deny_exceptions_write+=("$deny:$wp")
			fi
		done
		for rp in "${ro_paths[@]+"${ro_paths[@]}"}"; do
			if is_subpath_of "$rp" "$deny"; then
				deny_exceptions_ro+=("$deny:$rp")
			fi
		done
	done

	if [[ "${CCO_DEBUG:-}" == "1" ]]; then
		if [[ ${#deny_exceptions_write[@]} -gt 0 || ${#deny_exceptions_ro[@]} -gt 0 ]]; then
			echo "DEBUG: Allow-inside-deny exceptions:" >&2
			for exc in "${deny_exceptions_write[@]+"${deny_exceptions_write[@]}"}"; do
				echo "  write: ${exc#*:} (under ${exc%%:*})" >&2
			done
			for exc in "${deny_exceptions_ro[@]+"${deny_exceptions_ro[@]}"}"; do
				echo "  read-only: ${exc#*:} (under ${exc%%:*})" >&2
			done
		fi
	fi

	{
		echo "(version 1)"
		echo "(allow default)"

		# Deny ALL file writes first
		echo "(deny file-write*)"

		# Optional safe mode: deny reads under $HOME by default, re-allow below
		if [[ "$safe_mode" == true ]]; then
			printf '(deny file-read* (subpath "%s"))\n' "$(policy_quote "$HOME")"
		fi

		# Deny paths explicitly (BEFORE any allows that might be under them)
		# Seatbelt uses LAST-MATCH-WINS, so deny must come before allow exceptions
		for ap in "${deny_paths[@]+"${deny_paths[@]}"}"; do
			if [[ -d "$ap" ]]; then
				printf '(deny file-read* (subpath "%s"))\n' "$(policy_quote "$ap")"
				printf '(deny file-write* (subpath "%s"))\n' "$(policy_quote "$ap")"
			else
				printf '(deny file-read* (literal "%s"))\n' "$(policy_quote "$ap")"
				printf '(deny file-write* (literal "%s"))\n' "$(policy_quote "$ap")"
			fi
		done

		# Then allow only specific paths we need
		# 1. Current working directory
		printf '(allow file-write* (subpath "%s"))\n' "$(policy_quote "$PWD_ABS")"
		if [[ "$safe_mode" == true ]]; then
			printf '(allow file-read* (subpath "%s"))\n' "$(policy_quote "$PWD_ABS")"
		fi

		# 2. Additional paths passed via -w flags
		for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
			# Check if this write path is under any deny path - if so, also allow reads
			needs_read=false
			if [[ "$safe_mode" == true ]]; then
				needs_read=true
			else
				for deny in "${deny_paths[@]+"${deny_paths[@]}"}"; do
					if is_subpath_of "$ap" "$deny"; then
						needs_read=true
						break
					fi
				done
			fi

			if [[ -d "$ap" ]]; then
				printf '(allow file-write* (subpath "%s"))\n' "$(policy_quote "$ap")"
				if [[ "$needs_read" == true ]]; then
					printf '(allow file-read* (subpath "%s"))\n' "$(policy_quote "$ap")"
				fi
			else
				printf '(allow file-write* (literal "%s"))\n' "$(policy_quote "$ap")"
				if [[ "$needs_read" == true ]]; then
					printf '(allow file-read* (literal "%s"))\n' "$(policy_quote "$ap")"
				fi
			fi
		done

		# Read-only paths: allow reads but keep writes denied
		for ap in "${ro_paths[@]+"${ro_paths[@]}"}"; do
			if [[ -d "$ap" ]]; then
				printf '(allow file-read* (subpath "%s"))\n' "$(policy_quote "$ap")"
			else
				printf '(allow file-read* (literal "%s"))\n' "$(policy_quote "$ap")"
			fi
		done

		# 3. Temp directories (needed for Keychain and other operations)
		echo "(allow file-write* (subpath \"/tmp\"))"
		echo "(allow file-write* (subpath \"/var/tmp\"))"
		echo "(allow file-write* (subpath \"/var/folders\"))"
		echo "(allow file-write* (subpath \"/private/var/folders\"))"
		echo "(allow file-write* (subpath \"/private/tmp\"))"

		# 4. Common device files and pipes
		echo "(allow file-write* (literal \"/dev/null\"))"
		echo "(allow file-write* (literal \"/dev/zero\"))"
		echo "(allow file-write* (literal \"/dev/random\"))"
		echo "(allow file-write* (literal \"/dev/urandom\"))"
		echo "(allow file-write* (literal \"/dev/tty\"))"
		echo "(allow file-write* (literal \"/dev/stdin\"))"
		echo "(allow file-write* (literal \"/dev/stdout\"))"
		echo "(allow file-write* (literal \"/dev/stderr\"))"
		echo "(allow file-write* (literal \"/dev/fd\"))"

		# 5. User's Library folders that apps commonly need
		printf '(allow file-write* (subpath "%s/Library/Caches"))\n' "$(policy_quote "$HOME")"
		printf '(allow file-write* (subpath "%s/Library/Logs"))\n' "$(policy_quote "$HOME")"
		printf '(allow file-write* (subpath "%s/Library/Application Support"))\n' "$(policy_quote "$HOME")"

		# 6. Keychain access for OAuth token refresh (only if explicitly allowed)
		if [[ "$allow_keychain" == true ]]; then
			printf '(allow file-read* (subpath "%s/Library/Keychains"))\n' "$(policy_quote "$HOME")"
			printf '(allow file-read* (subpath "/Library/Keychains"))\n'
			printf '(allow file-write* (subpath "%s/Library/Keychains"))\n' "$(policy_quote "$HOME")"
			# Security framework and keychain services
			echo "(allow system-mac-syscall (syscall-number 73))" # keychain access
			echo "(allow mach-lookup (global-name \"com.apple.securityd\"))"
			echo "(allow mach-lookup (global-name \"com.apple.security.othersigning\"))"
			echo "(allow mach-lookup (global-name \"com.apple.security.credentialstore\"))"
		fi
	} >"$policy_file"

	# Note: sandbox-exec has limited options (-f, -n, -p, -D)
	# backend_extra_args can include things like -D for defining variables
	if [[ ${#backend_extra_args[@]} -gt 0 ]]; then
		sandbox-exec -f "$policy_file" "${backend_extra_args[@]}" "$@"
	else
		sandbox-exec -f "$policy_file" "$@"
	fi
	local status=$?
	if [[ "$keep_policy" == false ]]; then
		rm -f "$policy_file"
	fi
	exit $status
}

case "$OS" in
Linux) run_linux "$@" ;;
Darwin) run_macos "$@" ;;
*)
	echo "sandbox: unsupported OS: $OS" >&2
	exit 1
	;;
esac
