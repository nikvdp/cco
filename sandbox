#!/usr/bin/env bash
# sandbox - RW only in the current directory; RO everywhere else.
# Works on Linux (bubblewrap) and macOS (Seatbelt via sandbox-exec).
# Add extra write holes with -w/--write PATH (repeatable). PATH may be a dir or file.
# Env vars are inherited; networking is untouched.

set -euo pipefail

usage() {
	echo "Usage: sandbox [--safe] [--allow-keychain] [-w|--write PATH] [--read-only PATH] [--deny PATH]... [-- [BACKEND_ARGS...] --] <command> [args...]"
	echo "  PATH may be a directory (RW under it) or a file (RW to that file only)."
	echo "  --allow-keychain: Allow access to macOS Keychain (DANGEROUS - grants read/write access to ALL Keychain entries)"
	echo "  BACKEND_ARGS: Extra arguments passed directly to bwrap (Linux) or sandbox-exec (macOS)"
	echo "                Must be enclosed between -- markers if provided"
	exit 1
}

# Expand ~ and return absolute, symlink-free path (for dirs or files).
# For non-existent files, ensure parent exists and return absolute would-be path.
abs_path() {
	local p="$1"
	# manual tilde expansion (covers the case where user quoted it)
	if [[ "$p" == "~" || "$p" == ~/* ]]; then
		p="${p/#\~/$HOME}"
	fi
	if [[ -e "$p" ]]; then
		if [[ -d "$p" ]]; then
			(cd "$p" && pwd -P)
		else
			(cd "$(dirname -- "$p")" && printf '%s/%s\n' "$(pwd -P)" "$(basename -- "$p")")
		fi
	else
		local parent base
		parent="$(dirname -- "$p")"
		base="$(basename -- "$p")"
		[[ -d "$parent" ]] || {
			echo "sandbox: parent directory does not exist: $parent" >&2
			exit 2
		}
		(cd "$parent" && printf '%s/%s\n' "$(pwd -P)" "$base")
	fi
}

# Escape a path for Seatbelt policy quoting: escape \ and "
policy_quote() {
	local s="$1"
	s="${s//\\/\\\\}"
	s="${s//\"/\\\"}"
	printf '%s' "$s"
}

# Parse CLI
write_paths=()
ro_paths=()
deny_paths=()
backend_extra_args=()
safe_mode=false
allow_keychain=false
while [[ $# -gt 0 ]]; do
	case "$1" in
	--safe)
		safe_mode=true
		shift
		;;
	-w | --write)
		shift
		[[ $# -gt 0 ]] || usage
		write_paths+=("$(abs_path "$1")")
		shift
		;;
	--read-only)
		shift
		[[ $# -gt 0 ]] || usage
		ro_paths+=("$(abs_path "$1")")
		shift
		;;
	--deny)
		shift
		[[ $# -gt 0 ]] || usage
		deny_paths+=("$(abs_path "$1")")
		shift
		;;
	--allow-keychain)
		allow_keychain=true
		shift
		;;
	-h | --help) usage ;;
	--)
		shift
		# Collect backend args until we hit another -- or end of args
		while [[ $# -gt 0 && "$1" != "--" ]]; do
			backend_extra_args+=("$1")
			shift
		done
		# If we hit another --, skip it (it separates backend args from command)
		if [[ "${1:-}" == "--" ]]; then
			shift
		fi
		break
		;;
	-*)
		echo "sandbox: unknown option: $1" >&2
		usage
		;;
	*) break ;;
	esac
done
[[ $# -gt 0 ]] || usage

OS="$(uname -s)"
PWD_ABS="$(pwd -P)"

run_linux() {
	command -v bwrap >/dev/null 2>&1 || {
		echo "sandbox: bubblewrap (bwrap) is not installed." >&2
		exit 127
	}

	# Get the directory where this script is located (for finding seccomp filters)
	local script_dir
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	local seccomp_dir="$script_dir/seccomp"
	local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/cco"

	# Setup seccomp filter to block TIOCSTI/TIOCLINUX sandbox escape (CVE-2017-5226, CVE-2023-1523)
	local seccomp_filter=""
	local arch
	arch="$(uname -m)"

	case "$arch" in
	x86_64)
		if [[ -f "$seccomp_dir/tiocsti_filter_x86_64.bpf" ]]; then
			seccomp_filter="$seccomp_dir/tiocsti_filter_x86_64.bpf"
		fi
		;;
	aarch64)
		if [[ -f "$seccomp_dir/tiocsti_filter_aarch64.bpf" ]]; then
			seccomp_filter="$seccomp_dir/tiocsti_filter_aarch64.bpf"
		fi
		;;
	*)
		# Exotic architecture - try to compile from source
		local compiled_filter="$cache_dir/tiocsti_filter_${arch}.bpf"
		local source_file="$seccomp_dir/tiocsti_filter.c"
		local needs_rebuild=false

		# Check if we need to rebuild: no cache, or source is newer than cache
		if [[ ! -f "$compiled_filter" ]]; then
			needs_rebuild=true
		elif [[ -f "$source_file" && "$source_file" -nt "$compiled_filter" ]]; then
			needs_rebuild=true
		fi

		if [[ "$needs_rebuild" == true && -f "$source_file" ]]; then
			# Try to compile the filter
			if command -v cc >/dev/null 2>&1; then
				mkdir -p "$cache_dir"
				local filter_gen="$cache_dir/tiocsti_filter_gen"
				if cc -O2 -o "$filter_gen" "$source_file" 2>/dev/null; then
					if "$filter_gen" "$compiled_filter" >/dev/null 2>&1; then
						rm -f "$filter_gen"
					fi
				fi
			fi
		fi

		if [[ -f "$compiled_filter" ]]; then
			seccomp_filter="$compiled_filter"
		fi
		;;
	esac

	# Warn if we couldn't set up seccomp protection
	if [[ -z "$seccomp_filter" ]]; then
		echo "sandbox: WARNING: Could not set up TIOCSTI protection for architecture '$arch'." >&2
		echo "sandbox: The sandbox may be vulnerable to terminal injection attacks." >&2
		echo "sandbox: To fix on exotic architectures, install a C compiler (gcc/clang)." >&2
	fi

	# 1) Base: make root view RO; keep /dev, /proc, and a tmpfs /tmp; DO NOT unshare net.
	args=(--die-with-parent
		--ro-bind / /
		--dev /dev
		--proc /proc
		--tmpfs /tmp
	)

	# Add seccomp filter if available (blocks TIOCSTI/TIOCLINUX sandbox escape)
	# Use fd 200 to avoid collision with common inherited fds
	if [[ -n "$seccomp_filter" && -f "$seccomp_filter" ]]; then
		args+=(--seccomp 200)
	fi

	# 2) Common top-level mount points RO so writable mounts canâ€™t leak through.
	for p in /home /var /root /run /opt /srv /media /mnt /usr /etc /sys; do
		[[ -e "$p" ]] && args+=(--ro-bind "$p" "$p")
	done

	# 3) If safe mode enabled, hide the rest of $HOME by default.
	if [[ "$safe_mode" == true ]]; then
		args+=(--tmpfs "$HOME")
	fi

	# 4) Overlay rules (rw, ro, deny) so they take precedence.
	# Always include the current directory at its real path.
	args+=(--bind "$PWD_ABS" "$PWD_ABS")

	# Helper temp resources for deny overlays
	cleanup_paths=()
	cleanup_overlays() {
		for p in "${cleanup_paths[@]+"${cleanup_paths[@]}"}"; do
			if [[ -n "$p" && -e "$p" ]]; then
				rm -rf "$p"
			fi
		done
	}

	for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
		# Ensure targets exist so bind succeeds
		if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
		args+=(--bind "$ap" "$ap")
	done

	for ap in "${ro_paths[@]+"${ro_paths[@]}"}"; do
		if [[ -d "$ap" ]]; then
			args+=(--ro-bind "$ap" "$ap")
		else
			if [[ ! -e "$ap" ]]; then : >"$ap"; fi
			args+=(--ro-bind "$ap" "$ap")
		fi
	done

	for ap in "${deny_paths[@]+"${deny_paths[@]}"}"; do
		if [[ -d "$ap" ]]; then
			empty_dir=$(mktemp -d)
			cleanup_paths+=("$empty_dir")
			args+=(--ro-bind "$empty_dir" "$ap")
		elif [[ -f "$ap" ]]; then
			empty_file=$(mktemp)
			cleanup_paths+=("$empty_file")
			: >"$empty_file"
			args+=(--ro-bind "$empty_file" "$ap")
		else
			empty_dir=$(mktemp -d)
			cleanup_paths+=("$empty_dir")
			args+=(--ro-bind "$empty_dir" "$ap")
		fi
	done
	args+=(--chdir "$PWD_ABS")

	# Add any extra backend args
	if [[ ${#backend_extra_args[@]} -gt 0 ]]; then
		args+=("${backend_extra_args[@]}")
	fi

	# Execute bwrap with seccomp filter on fd 200 if available
	if [[ -n "$seccomp_filter" && -f "$seccomp_filter" ]]; then
		bwrap "${args[@]}" "$@" 200<"$seccomp_filter"
	else
		bwrap "${args[@]}" "$@"
	fi
	local status=$?
	cleanup_overlays
	exit $status
}

run_macos() {
	command -v sandbox-exec >/dev/null 2>&1 || {
		echo "sandbox: sandbox-exec not found on this macOS." >&2
		exit 127
	}

	# Ensure any whitelisted *files* exist so Seatbelt can actually write to them
	for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
		if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
	done
	for ap in "${ro_paths[@]+"${ro_paths[@]}"}"; do
		if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
	done
	for ap in "${deny_paths[@]+"${deny_paths[@]}"}"; do
		if [[ ! -d "$ap" && ! -e "$ap" ]]; then : >"$ap"; fi
	done

	# Build a Seatbelt profile that denies writes globally, then whitelists:
	# - The current directory (subpath)
	# - Any -w directories (subpath)
	# - Any -w files (literal)
	policy_file="$(mktemp -t sandbox.seatbelt.XXXXXX)"

	keep_policy=false
	if [[ "${CCO_DEBUG:-}" == "1" ]]; then
		echo "DEBUG: Seatbelt policy file: $policy_file" >&2
		echo "DEBUG: Write paths being added:" >&2
		printf "  PWD: %s\n" "$PWD_ABS" >&2
		for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
			printf "  Additional: %s\n" "$ap" >&2
		done
		keep_policy=true
	fi

	{
		echo "(version 1)"
		echo "(allow default)"

		# Deny ALL file writes first
		echo "(deny file-write*)"

		# Optional safe mode: deny reads under $HOME by default, re-allow below
		if [[ "$safe_mode" == true ]]; then
			printf '(deny file-read* (subpath "%s"))\n' "$(policy_quote "$HOME")"
		fi

		# Then allow only specific paths we need
		# 1. Current working directory
		printf '(allow file-write* (subpath "%s"))\n' "$(policy_quote "$PWD_ABS")"
		if [[ "$safe_mode" == true ]]; then
			printf '(allow file-read* (subpath "%s"))\n' "$(policy_quote "$PWD_ABS")"
		fi

		# 2. Additional paths passed via -w flags
		for ap in "${write_paths[@]+"${write_paths[@]}"}"; do
			if [[ -d "$ap" ]]; then
				printf '(allow file-write* (subpath "%s"))\n' "$(policy_quote "$ap")"
				if [[ "$safe_mode" == true ]]; then
					printf '(allow file-read* (subpath "%s"))\n' "$(policy_quote "$ap")"
				fi
			else
				printf '(allow file-write* (literal "%s"))\n' "$(policy_quote "$ap")"
				if [[ "$safe_mode" == true ]]; then
					printf '(allow file-read* (literal "%s"))\n' "$(policy_quote "$ap")"
				fi
			fi
		done

		# Read-only paths: allow reads but keep writes denied
		for ap in "${ro_paths[@]+"${ro_paths[@]}"}"; do
			if [[ -d "$ap" ]]; then
				printf '(allow file-read* (subpath "%s"))\n' "$(policy_quote "$ap")"
			else
				printf '(allow file-read* (literal "%s"))\n' "$(policy_quote "$ap")"
			fi
		done

		# Deny paths explicitly
		for ap in "${deny_paths[@]+"${deny_paths[@]}"}"; do
			if [[ -d "$ap" ]]; then
				printf '(deny file-read* (subpath "%s"))\n' "$(policy_quote "$ap")"
				printf '(deny file-write* (subpath "%s"))\n' "$(policy_quote "$ap")"
			else
				printf '(deny file-read* (literal "%s"))\n' "$(policy_quote "$ap")"
				printf '(deny file-write* (literal "%s"))\n' "$(policy_quote "$ap")"
			fi
		done

		# 3. Temp directories (needed for Keychain and other operations)
		echo "(allow file-write* (subpath \"/tmp\"))"
		echo "(allow file-write* (subpath \"/var/tmp\"))"
		echo "(allow file-write* (subpath \"/var/folders\"))"
		echo "(allow file-write* (subpath \"/private/var/folders\"))"
		echo "(allow file-write* (subpath \"/private/tmp\"))"

		# 4. Common device files and pipes
		echo "(allow file-write* (literal \"/dev/null\"))"
		echo "(allow file-write* (literal \"/dev/zero\"))"
		echo "(allow file-write* (literal \"/dev/random\"))"
		echo "(allow file-write* (literal \"/dev/urandom\"))"
		echo "(allow file-write* (literal \"/dev/tty\"))"
		echo "(allow file-write* (literal \"/dev/stdin\"))"
		echo "(allow file-write* (literal \"/dev/stdout\"))"
		echo "(allow file-write* (literal \"/dev/stderr\"))"
		echo "(allow file-write* (literal \"/dev/fd\"))"

		# 5. User's Library folders that apps commonly need
		printf '(allow file-write* (subpath "%s/Library/Caches"))\n' "$(policy_quote "$HOME")"
		printf '(allow file-write* (subpath "%s/Library/Logs"))\n' "$(policy_quote "$HOME")"
		printf '(allow file-write* (subpath "%s/Library/Application Support"))\n' "$(policy_quote "$HOME")"

		# 6. Keychain access for OAuth token refresh (only if explicitly allowed)
		if [[ "$allow_keychain" == true ]]; then
			printf '(allow file-read* (subpath "%s/Library/Keychains"))\n' "$(policy_quote "$HOME")"
			printf '(allow file-read* (subpath "/Library/Keychains"))\n'
			printf '(allow file-write* (subpath "%s/Library/Keychains"))\n' "$(policy_quote "$HOME")"
			# Security framework and keychain services
			echo "(allow system-mac-syscall (syscall-number 73))" # keychain access
			echo "(allow mach-lookup (global-name \"com.apple.securityd\"))"
			echo "(allow mach-lookup (global-name \"com.apple.security.othersigning\"))"
			echo "(allow mach-lookup (global-name \"com.apple.security.credentialstore\"))"
		fi
	} >"$policy_file"

	# Note: sandbox-exec has limited options (-f, -n, -p, -D)
	# backend_extra_args can include things like -D for defining variables
	if [[ ${#backend_extra_args[@]} -gt 0 ]]; then
		sandbox-exec -f "$policy_file" "${backend_extra_args[@]}" "$@"
	else
		sandbox-exec -f "$policy_file" "$@"
	fi
	local status=$?
	if [[ "$keep_policy" == false ]]; then
		rm -f "$policy_file"
	fi
	exit $status
}

case "$OS" in
Linux) run_linux "$@" ;;
Darwin) run_macos "$@" ;;
*)
	echo "sandbox: unsupported OS: $OS" >&2
	exit 1
	;;
esac
